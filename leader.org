* leader-org.el
:PROPERTIES:
:header-args: :tangle leader.el
:END:
** Utility functions
Contains miscellanious functions. Rename these to be leader-specific as to prevent the possibility of getting in the way of similarly named functions of other projects.
#+begin_src elisp
  (defun shell-command-check (cmd expected-out)
    "Calls CMD, then checks the output for EXPECTED-OUT.
    If it's present, return the output, else return nil."
    (let (
    	(cmd-ret (shell-command-to-string cmd))
    	)
      (when (string-match-p (regexp-quote expected-out) cmd-ret)
        cmd-ret)
      )
    )

  (defun spaced-string-to-list (str-in)
    "Converts a string full of space-separated items into a list of these items.
  STR-IN should be that string."
    (let (
  	(out-list (list))
  	)
      (with-temp-buffer
        (insert str-in)
        (goto-char (point-min))
        (while (search-forward " " nil t)
  	(push (buffer-substring-no-properties (save-excursion (backward-word) (point)) (1- (point))) out-list))
        )
      out-list
      )
    )

  (defun fetch-current-project-details ()
    "Fetch current project's details (microcontroller unit, programmer, and full project root directory) and return them as a list (in that same order).
  Will return nil if:
  1. A Makefile cannot be found
  2. The Makefile found is too far away directory-wise
  3. The Makefile is one generated by 'leader-new-project'"
    (let (
  	(potential-proj-makefile-dir (locate-dominating-file default-directory "Makefile"))
  	)
      (when potential-proj-makefile-dir
        (when (<= (- (with-temp-buffer
  		     (insert default-directory)
  		     (how-many "/" (point-min) (point-max)))
  		   (with-temp-buffer
  		     (insert potential-proj-makefile-dir)
  		     (how-many "/" (point-min) (point-max))))
  		2)
  	(with-temp-buffer
  	  (insert-file-contents (concat potential-proj-makefile-dir "Makefile"))
  	  (when (string-equal "# AUTO-GENERATED MAKEFILE" (buffer-substring-no-properties 1 26))
  		  ;;; TODO: Just use a capture group for this
  	    (let (
  		  (microcontroller (buffer-substring-no-properties (re-search-forward "MCU=") (prog2
  												  (end-of-line)
  												  (point))))
  		  (programmer (buffer-substring-no-properties (re-search-forward "PROGRAMMER=") (prog2
  												    (end-of-line)
  												    (point))))
  		  )
  	      (list :mcu microcontroller :programmer programmer :dir (expand-file-name potential-proj-makefile-dir))))
  	  )
  	)
        )
      )
    )
#+end_src
** Core Data
Contains constants of relevant data, such as the list of valid microcontroller units, VID/PIDs (soon), etc.
#+begin_src elisp
  (defconst avr-mcu-list (spaced-string-to-list (with-temp-buffer
  						(insert (shell-command-to-string "avr-gcc --target-help"))
  						(goto-char (point-min))
  						(replace-string "\n " "" nil (search-forward "Known MCU names:\n  ") (- (search-forward "\n\n") 2))
  						(goto-char (point-min))
  						(buffer-substring-no-properties (search-forward "Known MCU names:\n  ") (- (search-forward "\n\n") 2))))) ;;; Holy moly, this probably shouldn't be inlined
  ;;; TODO: Figure out whether the above should be in a let block, or whether it's fine as-is
  ;;; TODO: Add some safety to the above
  (defconst leader-required-cmd-lists (list
  				     (cons "make" (list "make -v" "GNU Make "))
  				     (cons "avr-gcc" (list "avr-gcc --version" "avr-gcc (GCC) "))
  				     (cons "avr-objcopy" (list "avr-objcopy --version" "GNU objcopy (GNU Binutils) ")))
    "An alist that contains a relevant/required command as the car, then as the cdr, a list to be applied onto 'shell-command-check' in order to check for the presence of the command.")
#+end_src
** User-Facing functions
Interactive functions for use by the end-user. Lots of cleaning up to be done here.
#+begin_src elisp
  (defun leader-doctor ()
    (interactive)
    (let (
  	(missing-cmds "")
  	)
      (dolist (cmd-cell leader-required-cmd-lists)
        (let (
  	    (cur-cmd (car cmd-cell))
  	    (sh-cmd-check-args (cdr cmd-cell))
  	    )
  	(unless (apply (function shell-command-check) sh-cmd-check-args)
  	  (setq missing-cmds (concat missing-cmds cur-cmds "\n")))))
      (if (string-empty-p missing-cmds)
  	(message "All the relevant commands are present!")
        (message "These commands were unavailable, install them if you would like to continue:\n%s" missing-cmds)))
    )

  (defun leader-new-project ()
    "Make a new AVR project."
    (interactive)
    (let* (
           (proj-dir-loc-name (read-directory-name "New AVR Project Directory: " default-directory "FALLBACK-DIRNAME"))
           (proj-dir-check (not (or
                    	       (file-exists-p proj-dir-loc-name)
                    	       (string-equal proj-dir-loc-name "FALLBACK-DIRNAME"))))
           (proj-name (file-name-nondirectory proj-dir-loc-name))
           )
      (if proj-dir-check
          (let* (
                 (programmer-selection (completing-read "What kind of programmer are you using? " (mapcar (lambda (element)
                    											  (cdr element))
                    											avr-programmer-product-id-alist)
                    				      nil t))
                 (programmer (cond
                    	    ((string-equal "Arduino" programmer-selection)
                    	     (downcase programmer-selection))
                    	    ((string-equal "USBasp" programmer-selection)
                    	     "usbasp-clone") ;;; May cause problems, but from what I understand, this just ignores any checks to PID/VID that may block the upload in the case of a non-official USBasp programmer
                    			     ;;; TODO: Add more accordingly
                    	    ))
                 (mcu (completing-read "Which microcontroller are you deploying to? " avr-mcu-list nil t))
                 )
  	  (make-directory (expand-file-name proj-dir-loc-name) t)
            (with-temp-buffer
              (insert (concat "# AUTO-GENERATED MAKEFILE\nPROG-NAME=" proj-name
                    	    "\nMCU=" mcu
                    	    "\nPROGRAMMER=" programmer
                    	    "\nSRC-DIR=src"
    			    "\nBUILD-DIR=build"
    			    "\n\nall: $(PROG-NAME)"
    			    "\n$(BUILD-DIR):"
    			    "\n\tmkdir -vp $(BUILD-DIR)"
    			    "\n\n$(PROG-NAME): $(BUILD-DIR)"
    			    "\n\tavr-gcc -mmcu=$(MCU) -Wall -Os -o $(BUILD-DIR)/$(PROG-NAME).elf $(SRC-DIR)/$(PROG-NAME).c"
    			    "\n\tavr-objcopy -j .text -j .data -O ihex $(BUILD-DIR)/$(PROG-NAME).elf $(BUILD-DIR)/$(PROG-NAME).hex"
    			    "\n\nclean:\n\trm -rf $(BUILD-DIR)"))
              (write-file (concat (expand-file-name proj-dir-loc-name) "/Makefile")))
            (cd (concat (expand-file-name proj-dir-loc-name) "/"))
    	  (mkdir "src")
    	  (dired default-directory)
            (message "Good to go! Project: \"%s\" is ready!" proj-name))
        (message "Something went wrong with the creation of the new project. Are you sure you named a new directory?"))
      ))

  (defun leader-build ()
    "Builds the current project."
    (interactive)
    (let (
  	(proj-list (fetch-current-project-details))
  	)
      (if proj-list
  	(let* (
  	       (proj-dir (plist-get proj-list :dir))
  	       (default-directory proj-dir)
  	       )
  	  (compile "make -k"))
        (message "Could not fetch the current project's details!"))))

  (defun leader-clean ()
    "Cleans the current project."
    (interactive)
    (let (
  	(proj-list (fetch-current-project-details))
  	)
      (if proj-list
  	(let* (
  	       (proj-dir (plist-get proj-list :dir))
  	       (default-directory proj-dir)
  	       )
  	  (compile "make clean")
  	  )
        (message "Could not fetch the current project's details!"))))
#+end_src
* Planning
** TODO Deployment functionality
Deployment should be done through the AVRDude utility, but I need to polish the underlying build-system first.
The idea is that the script can scan ports for relevant programmers then provide a list to a user when deploying a hex file to a microcontroller, with that list attempting to be as informative as possible
(Programmer name, port number, (when working with an arduino board) microcontroller type, etc).
AVRDude will then be called directly by the elisp, rather than going through the static Makefile intermediary as is more customary, in order to to account for the fact that, understandably, we're not
going to be putting the same programmer on the same port every time we want to flash firmware to the microcontroller.

