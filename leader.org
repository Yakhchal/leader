* leader.el
:PROPERTIES:
:header-args: :tangle leader.el
:END:
** Utility functions
Contains miscellanious functions. Rename these to be leader-specific as to prevent the possibility of getting in the way of similarly named functions of other projects.
#+begin_src elisp
    (defun shell-command-check (cmd expected-out &optional exclude)
      "Calls CMD, then checks the output for EXPECTED-OUT.
            If present, the function will return the output, else nil.
      
        If exclude is true, the opposite effect on the returning is done:
    If the string is present, the response is nil, else the output is returned."
      (let (
            (cmd-ret (shell-command-to-string cmd))
            )
        (if exclude
    	(unless (string-match-p (regexp-quote expected-out) cmd-ret)
              cmd-ret)
          (when (string-match-p (regexp-quote expected-out) cmd-ret)
            cmd-ret))))



    (defun spaced-string-to-list (str-in)
      "Converts a string full of space-separated items into a list of these items.
  STR-IN should be that string, and should not begin nor end with whitespace."
      (let (
          	(out-list (list))
          	)
        (with-temp-buffer
          (insert str-in)
          (goto-char (point-min))
          (while (search-forward " " nil t)
          	(push (buffer-substring-no-properties (save-excursion (backward-sexp) (point)) (1- (point))) out-list))
  	(push (buffer-substring-no-properties (point) (prog2
  							  (forward-sexp 1)
  							  (point)))
  	      out-list))
        (reverse out-list)
        ))

    (defun fetch-current-project-details ()
      "Fetch current project's associated microcontroller unit and full project root directory, returning them as a plist.
          Will return nil if:
          1. A Makefile cannot be found
          2. The Makefile found is too far away directory-wise
          3. The Makefile is not one generated by 'leader-new-project'"
      (let ((potential-proj-makefile-dir (locate-dominating-file default-directory "Makefile")))
        (when potential-proj-makefile-dir
          (when (<= (- (with-temp-buffer
          		     (insert default-directory)
          		     (how-many "/" (point-min) (point-max)))
          		   (with-temp-buffer
          		     (insert potential-proj-makefile-dir)
          		     (how-many "/" (point-min) (point-max))))
          		2)
          	(with-temp-buffer
          	  (insert-file-contents (concat potential-proj-makefile-dir "Makefile"))
          	  (when (string-equal "# AUTO-GENERATED MAKEFILE" (buffer-substring-no-properties 1 26))
  		    (let* (
  			  (prog-name (prog2 (re-search-forward "PROG-NAME=\\(.*\\)") (match-string 1)))
  			  (mcu (prog2 (re-search-forward "MCU=\\(.*\\)") (match-string 1)))
  			  (proj-dir (expand-file-name potential-proj-makefile-dir))
  			  )
          	      (list :mcu mcu :dir proj-dir :name prog-name))))))))
#+end_src
** Core Data
Contains constants of relevant data, such as the list of valid microcontroller units, VID/PIDs (soon), etc.

Another thing I've implemented is more explicit/nicer-to-read names for MCUs and programmers,
For example, rather than "m328p" being listed in the completing-read, we could have: "ATmega328P".

To remedy the fact that this isn't eye-to-eye with what avrdude expects, we'll have these lists be alists, with the 'car' being the fancy version, and 'cdr' being the
avrdude-expected value, that way after using 'completing-read' with an input list of a mapcar'ed 'avr-mcu-list', we can then feed the response directly to
'assoc' in order to get its associated avrdude input for the '--part' option.
#+begin_src elisp
  (defconst avr-mcu-list (with-temp-buffer
  			 (insert (shell-command-to-string "avrdude -p?"))
  			 (goto-char (point-min))
  			 (let ((mcu-list (list)))
  			   (while (save-excursion (search-forward "\n\s\s" nil t))
  			     (re-search-forward "\n\s\s\\(.*\\S-\\)\s+=\s\\(.*\\S-\\)\s+(")
  			     (push (cons (match-string 2) (match-string 1)) mcu-list))
  			   mcu-list)))
  (defconst avr-programmer-list (with-temp-buffer
  				(insert (shell-command-to-string "avrdude -c?"))
  				(goto-char (point-min))
  				(let ((prog-list (list)))
  				  (while (save-excursion (search-forward "\n\s\s" nil t))
  				    (re-search-forward "\n\s\s\\(.*\\S-\\)\s+=\s\\(.*\\S-\\)\s+(")
  				    (push (cons (match-string 2) (match-string 1)) prog-list))
  				  prog-list)))

  (defconst leader-required-cmd-lists (list
  				     (cons "make" (list "make -v" "GNU Make "))
  				     (cons "avr-gcc" (list "avr-gcc --version" "avr-gcc (GCC) "))
  				     (cons "avr-objcopy" (list "avr-objcopy --version" "GNU objcopy (GNU Binutils) ")))
    "An alist that contains a relevant/required command as the car, then as the cdr, a list to be applied onto 'shell-command-check' in order to check for the presence of the command.")
#+end_src
** User-Facing functions
Interactive functions for use by the end-user. Lots of cleaning up to be done here.
#+begin_src elisp
  (defun leader-doctor ()
    (interactive)
    (let (
  	(missing-cmds "")
  	)
      (dolist (cmd-cell leader-required-cmd-lists)
        (let (
  	    (cur-cmd (car cmd-cell))
  	    (sh-cmd-check-args (cdr cmd-cell))
  	    )
  	(unless (apply (function shell-command-check) sh-cmd-check-args)
  	  (setq missing-cmds (concat missing-cmds cur-cmds "\n")))))
      (if (string-empty-p missing-cmds)
  	(message "All the relevant commands are present!")
        (message "These commands were unavailable, install them if you would like to continue:\n%s" missing-cmds)))
    )

  (defun leader-new-project ()
    "Make a new AVR project."
    (interactive)
    (let* (
           (proj-dir-loc-name (read-directory-name "New AVR Project Directory: " default-directory "FALLBACK-DIRNAME"))
           (proj-dir-check (not (or
                    	       (file-exists-p proj-dir-loc-name)
                    	       (string-equal proj-dir-loc-name "FALLBACK-DIRNAME"))))
           (proj-name (file-name-nondirectory proj-dir-loc-name))
           )
      (if proj-dir-check
          (let* ((mcu (cdr (assoc (completing-read "Which microcontroller are you deploying to? " (mapcar (lambda (cell) (car cell)) avr-mcu-list) nil t) avr-mcu-list))))
  	  (make-directory (expand-file-name proj-dir-loc-name) t)
            (with-temp-buffer
              (insert (concat "# AUTO-GENERATED MAKEFILE\nPROG-NAME=" proj-name
                    	    "\nMCU=" mcu
                    	    "\nSRC-DIR=src"
    			    "\nBUILD-DIR=build"
    			    "\n\nall: $(PROG-NAME)"
    			    "\n$(BUILD-DIR):"
    			    "\n\tmkdir -vp $(BUILD-DIR)"
    			    "\n\n$(PROG-NAME): $(BUILD-DIR)"
    			    "\n\tavr-gcc -mmcu=$(MCU) -Wall -Os -o $(BUILD-DIR)/$(PROG-NAME).elf $(SRC-DIR)/$(PROG-NAME).c"
    			    "\n\tavr-objcopy -j .text -j .data -O ihex $(BUILD-DIR)/$(PROG-NAME).elf $(BUILD-DIR)/$(PROG-NAME).hex"
    			    "\n\nclean:\n\trm -rf $(BUILD-DIR)"))
              (write-file (concat (expand-file-name proj-dir-loc-name) "/Makefile")))
            (cd (concat (expand-file-name proj-dir-loc-name) "/"))
    	  (mkdir "src")
    	  (dired default-directory)
            (message "Good to go! Project: \"%s\" is ready!" proj-name))
        (message "Something went wrong with the creation of the new project. Are you sure you named a new directory?"))
      ))

  (defun leader-build ()
    "Builds the current project."
    (interactive)
    (let (
  	(proj-list (fetch-current-project-details))
  	)
      (if proj-list
  	(let* ((proj-dir (plist-get proj-list :dir))
  	       (default-directory proj-dir))
  	  (compile "make -k"))
        (message "Could not fetch the current project's details!"))))

  (defun leader-clean ()
    "Cleans the current project."
    (interactive)
    (let ((proj-list (fetch-current-project-details)))
      (if proj-list
  	(let* ((proj-dir (plist-get proj-list :dir))
  	       (default-directory proj-dir))
  	  (compile "make clean"))
        (message "Could not fetch the current project's details!"))))
#+end_src
* Planning
** TODO Deployment functionality
Deployment should be done through the AVRDude utility, but I need to polish the underlying build-system first.  The idea is that the script can scan ports for
relevant programmers then provide a list to a user when deploying a hex file to a microcontroller, with that list attempting to be as informative as possible
(Programmer name, port number, (when working with an arduino board) microcontroller type, etc).  AVRDude will then be called directly by the elisp, rather than
going through the static Makefile intermediary as is more customary, in order to to account for the fact that, understandably, we're not going to be putting the
same programmer on the same port every time we want to flash firmware to the microcontroller.

For fetching port info, we'll have separate functions for retrieving serial port information based on the system, which will be delegated to by an umbrella
function that decides which to call based on the value of 'system-type':
#+begin_src elisp
  (defun leader--get-port-info-windows ()
    "Fetch relevant port information via Powershell, then returns it as a property list.
  Returns a list containing property lists that correspond to each active port, or nil.
  The properties that will be returned are:
  :vid - The Vendor ID number of the device
  :pid - The Product ID number of the device
  :port - The name of the port (E.G. \"COM5\")

  If no objects are connected to serial ports, function will return nil."
    (let* (
  	 (port-info-json (shell-command-to-string "powershell -Command \"Get-WmiObject Win32_SerialPort | Select-Object DeviceID, PNPDeviceID | ConvertTo-Json\""))
  	 (info-list (unless (string-empty-p port-info-json)
  		      (json-parse-string port-info-json :object-type 'plist)))
  	 )
      (when info-list
        (if (arrayp info-list)
  	  (setq info-list (append info-list 'nil))
  	  (mapcar (lambda (port-plist)
  		    (let* (
  			   (devid (plist-get port-plist :PNPDeviceID))
  			   (vid (prog2
  				    (string-match "VID_\\(.\\{4\\}\\)" devid)
  				    (match-string 1 devid)))
  			   (pid (prog2
  				    (string-match "PID_\\(.\\{4\\}\\)" devid)
  				    (match-string 1 devid)))
  			   )
  		      (list
  		       :port (plist-get port-plist :DeviceID)
  		       :vid vid
  		       :pid pid
  		       )))
  		  info-list)
  	(list (list ;;; so it can mapcar accordingly
  	       :port (plist-get info-list :DeviceID)
  	       :vid (let ((devid (plist-get info-list :PNPDeviceID)))
  		      (string-match "VID_\\(.\\{4\\}\\)" devid)
  		      (match-string 1 devid))
  	       :pid (let ((devid (plist-get info-list :PNPDeviceID)))
  		      (string-match "PID_\\(.\\{4\\}\\)" devid)
  		      (match-string 1 devid))
  	       )))
        )
      )
    )
  )



  (defun leader--get-port-info-gnu/linux ()
    (let ((usbs-newlined (shell-command-check "ls -1 /dev/ttyUSB*" "cannot access" t)))
      (when usbs-newlined
        (let (
  	    (usb-list (let ((usb-list nil)) (with-temp-buffer
  					      (insert usbs-newlined)
  					      (goto-char (point-min))
  					      (while (save-excursion (re-search-forward "\n" nil t))
  						(push (buffer-substring-no-properties (point) (1- (re-search-forward "\n"))) usb-list)))))
  	    )
  	(seq-map (lambda (port-name)
  		   (list
  		    :port port-name
  		    :vid 'nil
  		    :pid 'nil
  		    ))
  		 usb-list)
  	)
        )
      )
    )



  (defun leader--get-port-info ()
    (cond
     ((eq system-type 'windows-nt)
      (leader--get-port-info-windows))
     ((eq system-type 'gnu/linux)
      (leader--get-port-info-gnu/linux))
     (t (error "This Operating System is not currently supported! Sorry!"))
     )
    )
#+end_src

I still need to figure how I should extract information like the vendor & product ID from the recognised ports on Linux: since I don't have a dedicated Linux
machine to plug these devices into, I can't do much hands on testing, and since different distros bundle different tools, and I want to ensure that this script
is as system-agnostic as possible, I am unsure whether I should use common (but not guaranteed) tooling like 'lshw' or 'udevadm', as they're common
(specifically the latter), but they're not a 100% chance. I suppose that if the Emacs editor is present in a fully-fledged-form that can actually use this
script, at /least/ 'udevadm' is present, so I suppose that's what I'll go with. (NOTE: Went with 'lshw' instead, since I did not know that udev is packaged
exclusively with systemd)

Now that we know which ports are present, we can move to actually querying 'avrdude' to upload the relevant project hex file.

First though, the function will query the user on which they'd like to pick. The format that the ports are presented to the user will just be the actual port
name (COM1, ttyUSB1, etc), but I hope to expand this to include the name/brand of the programmer/board connected to the port, based on the VID/PID.

#+begin_src elisp
  (defun leader--form-port-info (port-plist)
    (concat (plist-get port-plist :port) " --- ") ;;; TODO: Add the VID/PID decoding 
    )
#+end_src

Now that that's out of the way (Well, I still need to return to it in order to add the VID/PID decoding), we can form the user-facing function for uploading the
hex file of a specific project to the programmer on the selected port. I'll have the user formally enter the programmer for now, but perhaps in the future
leader could take a crack at guessing the appropriate programmer based on the VID/PID.

#+begin_src elisp
  (defun leader-upload ()
    (interactive)
    (let* (
  	(ports-list (leader--get-port-info))
  	(ports-formatted-alist (mapcar (lambda (port-plist)
  					 (cons (leader--form-port-info port-plist) (plist-get port-plist :port)) ;;; TODO: Probably rename some functions here so it's a bit clearer what each thing is
  				       ports-list)))
  	 (port-choice (cdr (assoc (completing-read "Which port is the programmer connected to?" ports-formatted-alist) ports-formatted-alist)))
  	 (programmer (cdr (assoc (completing-read "Which programmer are you using?" (mapcar (lambda (cell) (car cell)) avr-programmer-list) nil t) avr-programmer-list)))
  	 (proj-info-plist (fetch-current-project))
  	 (mcu (plist-get proj-info-plist :mcu))
  	 (proj-dir (plist-get proj-info-plist :dir))
  	 (prog-name (plist-get proj-info-plist :name))
  	 )
      (shell-command (concat "avrdude -v -c " programmer " -p " mcu " -P " port-choice " -U flash:w:" proj-dir "build/" prog-name ".hex:i"))
      ))
    
#+end_src

Writing this has made me realize that I need to commit either *fully* commiting to the idea of using a makefile for the sake of the ability to work with the
project outside Emacs /or/ abandon using Makefile altogether, opting to instead use a .dir-locals.el file for better integration with leader.
That's something I'll iron out at a later date.
** TODO Make a decision on using Makefile vs. .dir-locals.el
** DONE Create the VID/PID decoder
Turns out, there's not a particularly straightforward way to fetch relevant USB info (at least, not in elisp), and so I've decided to instead use the 'lshw'
package, which not only provides USB port details for all active ports, but also decodes the VID & PID for us, so it's just a matter of extracting the contents
of the shell command.
** TODO Give relevant functions relevant descriptions
** TODO Setup and test port information fetching
