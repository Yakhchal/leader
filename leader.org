* leader.el
:PROPERTIES:
:header-args: :tangle leader.el
:END:
** Utility functions
Contains miscellanious functions. Rename these to be leader-specific as to prevent the possibility of getting in the way of similarly named functions of other projects.
#+begin_src elisp
  (defun shell-command-check (cmd expected-out &optional exclude)
    "Calls CMD, then checks the output for EXPECTED-OUT.
                            If present, the function will return the output, else nil.
                      
                        If exclude is true, the opposite effect on the returning is done:
                    If the string is present, the response is nil, else the output is returned."
    (let (
          (cmd-ret (shell-command-to-string cmd))
          )
      (if exclude
          (unless (string-match-p (regexp-quote expected-out) cmd-ret)
            cmd-ret)
        (when (string-match-p (regexp-quote expected-out) cmd-ret)
          cmd-ret))))

  (defun leader-write-to-file (filepath contents)
    "Write CONTENTS to FILEPATH."
    (with-temp-buffer
      (insert contents)
      (write-file (expand-file-name filepath))))

  (defsubst leader-create-dirlocal-contents (proj-dir proj-name gcc-mcu avrdude-mcu)
    (concat "((nil . (
      (project-vc-extra-root-markers . '(\".dir-locals.el\"))
      \n(leader-local-proj-root . " proj-dir ")
      \n(leader-local-build-cmd . (lambda () (let ((default-directory " proj-dir ")) (shell-command-to-string \"avr-gcc -mmcu= " gcc-mcu " -Wall -Os -o " proj-name ".elf " proj-name ".c\") (shell-command-to-string \"avr-objcopy -j .text -j .data -O ihex " proj-name".elf " proj-name ".hex\"))))
  \n(leader-local-clean-cmd . (lambda () (let ((default-directory " proj-dir ")) (shell-command-to-string \"rm " proj-name ".elf " proj-name ".hex\"))))
    )
  ))"))

  (defvar leader-local-proj-root nil)
  (defvar leader-local-build-cmd nil)
  (defvar leader-local-clean-cmd nil)q
  (defvar leader-local-upload-cmd nil)
  (defvar leader-local-upload-simulator-cmd nil)

#+end_src
** Core Data
Contains constants of relevant data, such as the list of valid microcontroller units, VID/PIDs (soon), etc.

Another thing I've implemented is more explicit/nicer-to-read names for MCUs and programmers,
For example, rather than "m328p" being listed in the completing-read, we could have: "ATmega328P".

To remedy the fact that this isn't eye-to-eye with what avrdude expects, we'll have these lists be alists, with the 'car' being the fancy version, and 'cdr' being the
avrdude-expected value, that way after using 'completing-read' with an input list of a mapcar'ed 'avr-mcu-list', we can then feed the response directly to
'assoc' in order to get its associated avrdude input for the '--part' option.

*NOTE: As a result of avr-gcc and avrdude not playing nice name-wise, I'll have to hardcode the mcu list*
*NOTE x2: As a result of the fact that a function to create the list isn't too bad, I won't have to hardcode the aforementioned mcu list*
#+begin_src elisp
    (defun create-leader-microcontroller-list ()
      (let* (
      	 (avr-gcc-list (reverse (split-string (with-temp-buffer
      							 (insert (shell-command-to-string "avr-gcc --target-help"))
      							 (goto-char (point-min))
      							 (replace-string "\n " "" nil (search-forward "Known MCU names:\n  ") (- (search-forward "\n\n") 2))
      							 (goto-char (point-min))
      							 (buffer-substring-no-properties (search-forward "Known MCU names:\n  ") (- (search-forward "\n\n") 2)))
  					      " ")))
      	 (avrdude-list (with-temp-buffer
      			 (insert (shell-command-to-string "avrdude -p?"))
      			 (goto-char (point-min))
      			 (let ((mcu-list (list)))
      			   (while (save-excursion (search-forward "\n\s\s" nil t))
      			     (re-search-forward "\n\s\s\\(.*\\S-\\)\s+=\s\\(.*\\S-\\)\s+(")
      			     (let* ((fancy-name (match-string 2))
      				    (avrdude-friendly (match-string 1))
      				    (name-count (with-temp-buffer (insert fancy-name) (goto-char (point-min)) (how-many ","))))
      			       (cond
      				((eq name-count 0)
      				 (push (cons fancy-name avrdude-friendly) mcu-list))
      				((eq name-count 1)
      				 (let ((fancy-1 (prog2 (string-match "\\(.*\\),\s?\\(.*\\)" fancy-name) (match-string 1 fancy-name)))
      				       (fancy-2 (match-string 2 fancy-name)))
      				   (push (cons fancy-1 avrdude-friendly) mcu-list)
      				   (push (cons fancy-2 avrdude-friendly) mcu-list)))
      				((eq name-count 2)
      				 (let ((fancy-1 (prog2 (string-match "\\(.*\\),\s?\\(.*\\),\s?\\(.*\\)" fancy-name) (match-string 1 fancy-name)))
      				       (fancy-2 (match-string 2 fancy-name))
      				       (fancy-3 (match-string 3 fancy-name)))
      				   (push (cons fancy-1 avrdude-friendly) mcu-list)
      				   (push (cons fancy-2 avrdude-friendly) mcu-list)
      				   (push (cons fancy-3 avrdude-friendly) mcu-list)))
      				(t (error "AVRDUDE is providing a component with more than 3 synonyms. Get into contact with me (author) so I can fix this.")))))
      			   mcu-list)))
      	 (avr-gcc-compatible-avrdude-names (mapcar (lambda (cell)
      						     (downcase (car cell)))
      						   avrdude-list))
      	 (final-list (mapcar (lambda (cell)
      			       (let* ((gcc-compat-car (downcase (car cell)))
      				      (gcc-part-name nil))
      				 (cl-loop for part in avr-gcc-list
      					  until gcc-part-name
      					  do (when (string= gcc-compat-car part)
      					       (setq gcc-part-name part)))
      				 (when gcc-part-name
      				   (cons (car cell) (cons gcc-part-name (cdr cell))))
      				 )
      			       )
      			     avrdude-list))
      	 )
        (remove nil final-list)))
    ;;; Format of 'avr-mcu-list' is: (FANCY-NAME . (GCC-NAME . AVRDUDE-NAME))
    (defconst avr-mcu-list (create-leader-microcontroller-list))
    (defconst avr-programmer-list (with-temp-buffer
      				(insert (shell-command-to-string "avrdude -c?"))
      				(goto-char (point-min))
      				(let ((prog-list (list)))
      				  (while (save-excursion (search-forward "\n\s\s" nil t))
      				    (re-search-forward "\n\s\s\\(.*\\S-\\)\s+=\s\\(.*\\S-\\)\s+(")
      				    (push (cons (match-string 2) (match-string 1)) prog-list))
      				  prog-list)))

    (defconst leader-required-cmd-lists (list
      				     (cons "make" (list "make -v" "GNU Make "))
      				     (cons "avr-gcc" (list "avr-gcc --version" "avr-gcc (GCC) "))
      				     (cons "avr-objcopy" (list "avr-objcopy --version" "GNU objcopy (GNU Binutils) ")))
      "An alist that contains a relevant/required command as the car, then as the cdr, a list to be applied onto 'shell-command-check' in order to check for the presence of the command.")
#+end_src
** User-Facing functions
Interactive functions for use by the end-user. Lots of cleaning up to be done here.
#+begin_src elisp
  (defun leader-doctor ()
    (interactive)
    (let ((missing-cmds ""))
      (dolist (cmd-cell leader-required-cmd-lists)
        (let ((cur-cmd (car cmd-cell))
  	    (sh-cmd-check-args (cdr cmd-cell)))
  	(unless (apply (function shell-command-check) sh-cmd-check-args)
  	  (setq missing-cmds (concat missing-cmds cur-cmds "\n")))))
      (if (string-empty-p missing-cmds)
  	(message "All the relevant commands are present!")
        (message "These commands were unavailable, install them if you would like to continue:\n%s" missing-cmds)))
    )

  (defun leader-new-project ()
    "Make a new AVR project."
    (interactive)
    (let* (
           (proj-dir-loc-name (read-directory-name "New AVR Project Directory: " default-directory "FALLBACK-DIRNAME"))
           (proj-dir-check (not (or
                    	       (file-exists-p proj-dir-loc-name)
                    	       (string-equal proj-dir-loc-name "FALLBACK-DIRNAME"))))
           (proj-name (file-name-nondirectory proj-dir-loc-name))
           )
      (if proj-dir-check
          (let* ((mcu-cons (cdr (assoc (completing-read "Which microcontroller are you deploying to? " (mapcar (lambda (cell) (car cell)) avr-mcu-list) nil t) avr-mcu-list)))
  	       (mcu-gcc (car mcu-cons))
  	       (mcu-avrdude (cdr mcu-cons)))
  	  (make-directory (expand-file-name proj-dir-loc-name) t)
            (cd (concat (expand-file-name proj-dir-loc-name) "/"))
  	  (leader-write-file (concat (expand-file-name proj-dir-loc-name) "/.dir-locals.el") (leader-create-dirlocal-contents (concat proj-dir-loc-name "/") proj-name mcu-gcc mcu-avrdude))
  	  (find-file (concat (expand-file-name proj-dir-loc-name) "/" proj-name ".c"))
            (message "Good to go! Project: \"%s\" is ready!" proj-name))
        (message "Something went wrong with the creation of the new project. Are you sure you named a new directory?"))
      ))

  (defun leader-build ()
    "Builds the current project."
    (interactive)
    (if leader-local-build-cmd
        (funcall leader-local-build-cmd)
      (message "Could not fetch the current project's details!")))

  (defun leader-clean ()
    "Cleans the current project."
    (interactive)
    (if leader-local-clean-cmd
        (funcal leader-local-clean-cmd)
      (message "Could not fetch the current project's details!")))
#+end_src
* Planning
** TODO Add MCU emulation to deploy compiled code onto
A good way to determine whether code is working is to run it through a simulation of being deployed onto the MCU, and being able to do this easily would be
fantastic. I believe that using the simavr project with avr-gdb would be the best way to achieve this, but there are some things I must take into consideration.

Firstly, how will the user get SimAVR installed? AVR-GDB is available on most package archives, whereas SimAVR appears to be limited to a specific APT/dpkg
archive, which makes it more difficult to install for users on other distributions with different package managers (pacman, dnf, etc).

Secondly, what can I do to enrich usage with leader over just running avr-gdb through the terminal? Of course, leader can make the workflow of building ->
debugging more streamlined, but what can I do to make the interface better on the avr-gdb end, such as how 'gdb-many-windows' in Emacs makes GDB better to work
with. I suppose this is something I can tackle later, I just need to focus on getting the basics working.
** TODO Deployment functionality
Deployment should be done through the AVRDude utility, but I need to polish the underlying build-system first.  The idea is that the script can scan ports for
relevant programmers then provide a list to a user when deploying a hex file to a microcontroller, with that list attempting to be as informative as possible
(Programmer name, port number, (when working with an arduino board) microcontroller type, etc).  AVRDude will then be called directly by the elisp, rather than
going through the static Makefile intermediary as is more customary, in order to to account for the fact that, understandably, we're not going to be putting the
same programmer on the same port every time we want to flash firmware to the microcontroller.

For fetching port info, we'll have separate functions for retrieving serial port information based on the system, which will be delegated to by an umbrella
function that decides which to call based on the value of 'system-type':
#+begin_src elisp
  (defun leader--get-port-info-windows ()
    "Fetch relevant port information via Powershell, then returns it as a property list.
  Returns a list containing property lists that correspond to each active port, or nil.
  The properties that will be returned are:
  :vid - The Vendor ID number of the device
  :pid - The Product ID number of the device
  :port - The name of the port (E.G. \"COM5\")

  If no objects are connected to serial ports, function will return nil."
    (let* (
  	 (port-info-json (shell-command-to-string "powershell -Command \"Get-WmiObject Win32_SerialPort | Select-Object DeviceID, PNPDeviceID | ConvertTo-Json\""))
  	 (info-list (unless (string-empty-p port-info-json)
  		      (json-parse-string port-info-json :object-type 'plist)))
  	 )
      (when info-list
        (if (arrayp info-list)
  	  (setq info-list (append info-list 'nil))
  	  (mapcar (lambda (port-plist)
  		    (let* (
  			   (devid (plist-get port-plist :PNPDeviceID))
  			   (vid (prog2
  				    (string-match "VID_\\(.\\{4\\}\\)" devid)
  				    (match-string 1 devid)))
  			   (pid (prog2
  				    (string-match "PID_\\(.\\{4\\}\\)" devid)
  				    (match-string 1 devid)))
  			   )
  		      (list
  		       :port (plist-get port-plist :DeviceID)
  		       :vid vid
  		       :pid pid
  		       )))
  		  info-list)
  	(list (list ;;; so it can mapcar accordingly
  	       :port (plist-get info-list :DeviceID)
  	       :vid (let ((devid (plist-get info-list :PNPDeviceID)))
  		      (string-match "VID_\\(.\\{4\\}\\)" devid)
  		      (match-string 1 devid))
  	       :pid (let ((devid (plist-get info-list :PNPDeviceID)))
  		      (string-match "PID_\\(.\\{4\\}\\)" devid)
  		      (match-string 1 devid))
  	       )))
        )
      )
    )
  )



  (defun leader--get-port-info-gnu/linux ()
    (let ((usbs-newlined (shell-command-check "ls -1 /dev/ttyUSB*" "cannot access" t)))
      (when usbs-newlined
        (let (
  	    (usb-list (let ((usb-list nil)) (with-temp-buffer
  					      (insert usbs-newlined)
  					      (goto-char (point-min))
  					      (while (save-excursion (re-search-forward "\n" nil t))
  						(push (buffer-substring-no-properties (point) (1- (re-search-forward "\n"))) usb-list)))))
  	    )
  	(seq-map (lambda (port-name)
  		   (list
  		    :port port-name
  		    :vid 'nil
  		    :pid 'nil
  		    ))
  		 usb-list)
  	)
        )
      )
    )



  (defun leader--get-port-info ()
    (cond
     ((eq system-type 'windows-nt)
      (leader--get-port-info-windows))
     ((eq system-type 'gnu/linux)
      (leader--get-port-info-gnu/linux))
     (t (error "This Operating System is not currently supported! Sorry!"))
     )
    )
#+end_src

I still need to figure how I should extract information like the vendor & product ID from the recognised ports on Linux: since I don't have a dedicated Linux
machine to plug these devices into, I can't do much hands on testing, and since different distros bundle different tools, and I want to ensure that this script
is as system-agnostic as possible, I am unsure whether I should use common (but not guaranteed) tooling like 'lshw' or 'udevadm', as they're common
(specifically the latter), but they're not a 100% chance. I suppose that if the Emacs editor is present in a fully-fledged-form that can actually use this
script, at /least/ 'udevadm' is present, so I suppose that's what I'll go with. (NOTE: Went with 'lshw' instead, since I did not know that udev is packaged
exclusively with systemd)

Now that we know which ports are present, we can move to actually querying 'avrdude' to upload the relevant project hex file.

First though, the function will query the user on which they'd like to pick. The format that the ports are presented to the user will just be the actual port
name (COM1, ttyUSB1, etc), but I hope to expand this to include the name/brand of the programmer/board connected to the port, based on the VID/PID.

#+begin_src elisp
  (defun leader--form-port-info (port-plist)
    (concat (plist-get port-plist :port) " --- ") ;;; TODO: Add the VID/PID decoding 
    )
#+end_src

Now that that's out of the way (Well, I still need to return to it in order to add the VID/PID decoding), we can form the user-facing function for uploading the
hex file of a specific project to the programmer on the selected port. I'll have the user formally enter the programmer for now, but perhaps in the future
leader could take a crack at guessing the appropriate programmer based on the VID/PID.

#+begin_src elisp
  (defun leader-upload ()
    (interactive)
    (let* (
  	(ports-list (leader--get-port-info))
  	(ports-formatted-alist (mapcar (lambda (port-plist)
  					 (cons (leader--form-port-info port-plist) (plist-get port-plist :port)) ;;; TODO: Probably rename some functions here so it's a bit clearer what each thing is
  				       ports-list)))
  	 (port-choice (cdr (assoc (completing-read "Which port is the programmer connected to?" ports-formatted-alist) ports-formatted-alist)))
  	 (programmer (cdr (assoc (completing-read "Which programmer are you using?" (mapcar (lambda (cell) (car cell)) avr-programmer-list) nil t) avr-programmer-list)))
  	 (proj-info-plist (fetch-current-project))
  	 (mcu (plist-get proj-info-plist :mcu-avrdude))
  	 (proj-dir (plist-get proj-info-plist :dir))
  	 (prog-name (plist-get proj-info-plist :name))
  	 )
      (shell-command (concat "avrdude -v -c " programmer " -p " mcu " -P " port-choice " -U flash:w:" proj-dir "build/" prog-name ".hex:i"))
      ))
    
#+end_src

Writing this has made me realize that I need to commit either *fully* commiting to the idea of using a makefile for the sake of the ability to work with the
project outside Emacs /or/ abandon using Makefile altogether, opting to instead use a .dir-locals.el file for better integration with leader.
That's something I'll iron out at a later date.
** DONE Make a decision on using Makefile vs. .dir-locals.el
I think I'll go with *.dir-locals.el* /for now/. A Makefile helps with making the project usable outside of Emacs, and the .dir-locals allows for specific things to be made easier,
such as project.el recognition of the project root through setting 'project-find-functions' for the directory and integrating avrdude with elisp. To reduce
confusion while things are still being developed, I'll stick with the .dir-locals.el option, then add back the Makefile functionality at a later date.

** TODO Create the VID/PID decoder
Turns out, there's not a particularly straightforward way to fetch relevant USB info (at least, not in elisp), and so I've decided to instead use the 'lshw'
package, which not only provides USB port details for all active ports, but also decodes the VID & PID for us, so it's just a matter of extracting the contents
of the shell command.

Issue is, I don't have a dedicated GNU/Linux machine to plug a board/programmer into in order to work out the potential quirks of using 'lshw' and GNU/Linux
deployment. 
** TODO Give relevant functions relevant descriptions
** TODO Setup and test port information fetching
** DONE Fix the fact that the avr-mcu-list doesn't see eye-to-eye with avr-gcc
This is an easy fix: Just have the 'cdr' be a cons cell containing the avr-gcc & avrdude compatible part names.
Turns out, this isn't an easy fix! Since avrdude and avr-gcc output their microcontrollers with different names *in a different order*, I have no immediate way
to match them up.

I suppose I could just hard-code the board names into this script; it'd give me more control over them, and they'd be less unruly to work
with, but I have a nagging feeling that it's not the best way to do this. I'll do it anyway, but I'll revisit this if I have any other ideas in the future

Hardcoding it isn't much easier, as it turns out. The list of parts is extensive, and in the sea of various MCUs, I am unable to tell which are defunct and
unused and which are commonly used. In order to cut down on this, I'll just begin by hard-coding the boards that are present to be simulated within the SimulIDE
project.

For now, I'll keep this as is, *however*, I'd like to reopen this issue and create a convoluted system to cross-reference the verbose human-readable, but
downcased output of  'avrdude -p?' with the targets output from 'avr-gcc --target-help' in order to form a naive list of overlap.

After a little bit of manual list-building (I couldn't think of a better name), I realized that there is a fairly clear pattern:
'avr-gcc' is identical with a downcased version of the fancy name associated with the corresponding 'avrdude' part option.
This means, that by putting together a function to try and match every avr-gcc part with every avrdude part, then return a corresponding alist that looks like:
'(human-readable-name . (avr-gcc-compatible . avrdude-compatible))'

One snafu is that some of the avr-dude human-readable names have multiple names per. I have a dilemma: either I have two listings, one for each of the two
human-readable names, each with the same 'cdr', or, we discard the second name and just have one listing with the first human-readable name. I think I prefer
the former, but this is all making my head hurt.

One additional issue is that all this list-sorting is fairly intensive, and so I am unsure how I should reconcile that. Perhaps I could bundle this current list
directly as a variable, and give the user the opportunity to update it if they'd like... but that sounds like an odd solution. I'll consult the IRC when I get
the time (and when I've actually finished the function).

After closing in on finishing up the function, I realised that what I'm hoping to do (in the worst case scenario), will have to loop *128,310* times. Not only
is this already unacceptable usually, the salt in the wound is that it's all in linked lists (which are not fast).
Looking at the number of entries, 'avrdude' supports 470 parts but 'avr-gcc' supports only 273. While not attractive to manually enter, with the help of lisp
macros combined with the fact that many of the names are just derivatives of a base name, with a different number/sequence of numbers on the end, I think it may
be more feasible to do this manually, *especially* in the face of the prospect of having to conduct *128,310* linked list searches.

I may revisit this, as the resulting list that would be computed would only be (at most) 273 lines in a list. It takes ~3 seconds for 600 lines to be processed,
so we can make the bad estimation of 1278 seconds in the worst case scenario, which is around 21 minutes. Seems feasible to calculate, but I'd better make sure
that the function is good enough to work on the first try.

After putting together the function, and upon running, I realise that it's surprisingly quick.
I'll consider this resolved, as the list is fairly quick to produce (no idea how it was taking ~3 seconds for those 600 lines, I must've been imagining it at
the time (it was fairly late at night to be fair)).
#+begin_src elisp
  (defun create-leader-part-list ()
    (interactive)
    (let* (
  	 (avr-gcc-list (reverse (spaced-string-to-list (with-temp-buffer
  							 (insert (shell-command-to-string "avr-gcc --target-help"))
  							 (goto-char (point-min))
  							 (replace-string "\n " "" nil (search-forward "Known MCU names:\n  ") (- (search-forward "\n\n") 2))
  							 (goto-char (point-min))
  							 (buffer-substring-no-properties (search-forward "Known MCU names:\n  ") (- (search-forward "\n\n") 2))))))
  	 (avrdude-list (with-temp-buffer
  			 (insert (shell-command-to-string "avrdude -p?"))
  			 (goto-char (point-min))
  			 (let ((mcu-list (list)))
  			   (while (save-excursion (search-forward "\n\s\s" nil t))
  			     (re-search-forward "\n\s\s\\(.*\\S-\\)\s+=\s\\(.*\\S-\\)\s+(")
  			     (let* ((fancy-name (match-string 2))
  				    (avrdude-friendly (match-string 1))
  				    (name-count (with-temp-buffer (insert fancy-name) (goto-char (point-min)) (how-many ","))))
  			       (cond
  				((eq name-count 0)
  				 (push (cons fancy-name avrdude-friendly) mcu-list))
  				((eq name-count 1)
  				 (let ((fancy-1 (prog2 (string-match "\\(.*\\),\s?\\(.*\\)" fancy-name) (match-string 1 fancy-name)))
  				       (fancy-2 (match-string 2 fancy-name)))
  				   (push (cons fancy-1 avrdude-friendly) mcu-list)
  				   (push (cons fancy-2 avrdude-friendly) mcu-list)))
  				((eq name-count 2)
  				 (let ((fancy-1 (prog2 (string-match "\\(.*\\),\s?\\(.*\\),\s?\\(.*\\)" fancy-name) (match-string 1 fancy-name)))
  				       (fancy-2 (match-string 2 fancy-name))
  				       (fancy-3 (match-string 3 fancy-name)))
  				   (push (cons fancy-1 avrdude-friendly) mcu-list)
  				   (push (cons fancy-2 avrdude-friendly) mcu-list)
  				   (push (cons fancy-3 avrdude-friendly) mcu-list)))
  				(t (error "AVRDUDE is providing a component with more than 3 synonyms. Get into contact with me (author) so I can fix this.")))))
  			   mcu-list)))
  	 (avr-gcc-compatible-avrdude-names (mapcar (lambda (cell)
  						     (downcase (car cell)))
  						   avrdude-list))
  	 (final-list (mapcar (lambda (cell)
  			       (let* ((gcc-compat-car (downcase (car cell)))
  				      (gcc-part-name nil))
  				 (cl-loop for part in avr-gcc-list
  					  until gcc-part-name
  					  do (when (string= gcc-compat-car part)
  					       (setq gcc-part-name part)))
  				 (when gcc-part-name
  				   (cons (car cell) (cons gcc-part-name (cdr cell))))
  				 )
  			       )
  			     avrdude-list))
  	 )
      (remove nil final-list)
      )
    )
#+end_src

This puts me onto another thing to get finished up later: I had reinvented the wheel (badly) with the 'spaced-string-to-list' function, of which's functionality
is done better by 'split-string'. I'll replace all occurences later.
** DONE Replace 'spaced-string-to-list' with 'split-string'
Pretty simple fix. 'spaced-string-to-list' was implemented for something that was deemed obselete in earlier commits, so there was only one occurance (within
the part list generator), which was an easy fix.
** DONE Decide whether or not the best course of action would be to make a "main.c" rather than a "[project-name].c" file
[project-name].c would probably be the best way. The 'main.c' approach could be good for larger scale projects, but what I'm making isn't exactly suitable for
that anyway.
